<h1>Network Modelling</h1><p>Clojure software architects often say that we add schemas "at the boundaries"</p><p>Sketch allows you to model and test the entire system with those boundaries, before building and deploying any components.</p><h2>Why</h2><ul><li>network systems are hard to reason about before built</li><li>can't test distributed assertions until built</li><li>hard to uncover design bugs like race conditions, cache invalidation, etc</li><li>distributed systems grow in complexity quickly</li><li>hard to think about high level system</li><li>initial naming is easy but also easy to diverge from initial naming standard</li><li>hard to communicate designs before built</li></ul><h2>How</h2><ul><li>start with EDN declaration of system shape<ul><li>actors</li><li>state</li><li>domain entities</li><li>data flow events<ul><li>request/response</li><li>unidirectional (web-socket or Queue)</li></ul></li><li>schema key naming: source, target or event focused naming TODO</li></ul></li><li>tools<ul><li>bootstrap Malli schema<ul><li>manually populate schemas maintaining naming standard</li></ul></li><li>sync Malli schema as db changes<ul><li>file watcher</li><li>rewrite-clj diffs schemas and adds missing keywords in alphabetical order</li></ul></li><li>validate<ul><li>schema names stick to naming standard</li><li>schema keywords follow idioms e.g. kebab-case everywhere</li><li>decoders (h/t Malli) for non-clojure keys</li></ul></li><li>generate diagrams<ul><li>data flow sequence</li><li>distributed state changes after each data flow event</li></ul></li><li>generate non-clojure code<ul><li>Typescript/Zod TODO</li><li>Apex TODO</li><li>Malli<ul><li>JSON Schema</li><li>Open API</li></ul></li></ul></li></ul></li><li>testing<ul><li>composable steps tell the story of data flow<ul><li>add network events as stories grow</li></ul></li><li>composable chapters (step sequences)</li><li>state and data flow automatically checked using Malli schemas</li><li>state data flow for non-clojure systems use local idioms e.g. camelCase for JSON</li><li>assertions can be made about state anywhere e.g. check race conditions</li><li>create fns using domain data<ul><li>add (optional) fn schemas to avoid data bugs</li><li>informs implementations later during build</li></ul></li><li>verify decoders adapt data everywhere</li><li>artifacts<ul><li>generated diagrams<ul><li>sequence diagrams for each story/chapter/step</li></ul></li><li>actor fns</li><li>decoders</li></ul></li><li>run on jvm or node using cljc<ul><li>jvm Malli DX tools better</li></ul></li><li>exceptions<ul><li>Cursive Seeker link to failing step</li></ul></li></ul></li></ul><h2>Results</h2><ul><li>design system before implementation</li><li>reasoning about total system easier with diagrams (state and sequence)</li><li>enforced naming standards means easier to remember<ul><li>data flow events and names</li><li>schema names</li></ul></li><li>kebab-case keywords in all modelling and tests<ul><li>less mistakes forgetting which key style is used where</li></ul></li><li>Malli schemas for state and data flow ready for implementations</li><li>full inventory of network communications</li><li>shift left on design bugs</li><li>communicate with diagrams before initial build</li><li>avoid naming standard drift</li><li>generate non-clojure code if required</li></ul><h2>Influences</h2><p>https://github.com/clj-commons/rewrite-clj/blob/main/doc/01-user-guide.adoc</p>