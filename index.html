<!DOCTYPE html>
<html><head><meta charset="UTF-8"><meta content="width=device-width, initial-scale=1" name="viewport"><title>Sketch: Network Modelling</title><link href="docs.css" rel="stylesheet" type="text/css"></head><body><div class="content"><h1>Sketch: Network Modelling</h1><p>Clojure software architects often say that we add schemas "at the boundaries"</p><p>Sketch allows you to model and test the entire system with those boundaries, before building and deploying any components.</p><p>https://github.com/nextdoc/sketch</p><h2>Demo</h2><p>This test... https://github.com/nextdoc/sketch/blob/main/examples/mobile<i>weather</i>app/happy<i>path</i>test.clj generates this static html file when run... https://nextdoc.github.io/sketch/mobile-weather-app/happy-path-test.html</p><p>The actors and the step labels are clickable and this will display the state stored by each actor at any step in the test. This makes it a very effective storytelling tool.</p><p>You can clone this repo and run it yourself locally if you want to play with it. If you do clone it, you can try the following:</p><ul><li>Change one of the emitted messages and see that data-flow is validated by the test</li><li>Change some of the data that is persisted to storage and see that state is validated by the test</li><li>Comment out some of the test steps and see the diagram change when the test is run</li></ul><h2>Why</h2><ul><li>network systems are hard to reason about before built</li><li>can't test distributed assertions until built</li><li>hard to uncover design bugs like race conditions, cache invalidation, etc</li><li>distributed systems grow in complexity quickly</li><li>hard to think about high level system</li><li>initial naming is easy but also easy to diverge from initial naming standard</li><li>hard to communicate designs before built</li></ul><h2>How</h2><ul><li>start with EDN declaration of system shape<ul><li>actors</li><li>state</li><li>domain entities</li><li>data flow events<ul><li>request/response</li><li>unidirectional (web-socket or Queue)</li></ul></li><li>schema key naming: source, target or event focused naming TODO</li></ul></li><li>tools<ul><li>bootstrap Malli schema<ul><li>manually populate schemas maintaining naming standard</li></ul></li><li>sync Malli schema as db changes<ul><li>file watcher</li><li>rewrite-clj diffs schemas and adds missing keywords in alphabetical order</li></ul></li><li>validate<ul><li>schema names stick to naming standard</li><li>schema keywords follow idioms e.g. kebab-case everywhere</li><li>decoders (h/t Malli) for non-clojure keys</li></ul></li><li>generate diagrams<ul><li>data flow sequence</li><li>distributed state changes after each data flow event</li></ul></li><li>generate non-clojure code<ul><li>Typescript/Zod TODO</li><li>Apex TODO</li><li>Malli<ul><li>JSON Schema</li><li>Open API</li></ul></li></ul></li></ul></li><li>testing<ul><li>composable steps tell the story of data flow<ul><li>add network events as stories grow</li></ul></li><li>composable chapters (step sequences)</li><li>state and data flow automatically checked using Malli schemas</li><li>state data flow for non-clojure systems use local idioms e.g. camelCase for JSON</li><li>assertions can be made about state anywhere e.g. check race conditions</li><li>create fns using domain data<ul><li>add (optional) fn schemas to avoid data bugs</li><li>informs implementations later during build</li></ul></li><li>verify decoders adapt data everywhere</li><li>artifacts<ul><li>generated diagrams<ul><li>sequence diagrams for each story/chapter/step</li></ul></li><li>actor fns</li><li>decoders</li></ul></li><li>run on jvm or node using cljc<ul><li>jvm Malli DX tools better</li></ul></li><li>exceptions<ul><li>Cursive Seeker link to failing step</li></ul></li></ul></li></ul><h2>Results</h2><ul><li>design system before implementation</li><li>reasoning about total system easier with diagrams (state and sequence)</li><li>enforced naming standards means easier to remember<ul><li>data flow events and names</li><li>schema names</li></ul></li><li>kebab-case keywords in all modelling and tests<ul><li>less mistakes forgetting which key style is used where</li></ul></li><li>Malli schemas for state and data flow ready for implementations</li><li>full inventory of network communications</li><li>shift left on design bugs</li><li>communicate with diagrams before initial build</li><li>avoid naming standard drift</li><li>generate non-clojure code if required</li></ul><h2>Status</h2><h2><ul><li>Early alpha: likely to change but we'll endeavour to keep the test API stable</h2></li></ul><h2>Influences</h2><p>https://github.com/clj-commons/rewrite-clj/blob/main/doc/01-user-guide.adoc</p></div></body></html>